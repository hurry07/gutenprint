The dithering code in print-dither.c attempts to reproduce various
shades of gray (or all colors) from only a few different inks (black,
cyan, magenta, yellow, and sometimes light cyan and light magenta).
The dots can't vary in darkness or size (except for certain special
printers), and so we need to lay down a certain fraction of dots to
represent each distinct level.

This sounds straightforward; in practice, it isn't.  Completely random
distribution of dots (simple probabilistic dithering) would create
grainy clumps and light spots.  The smoothest pattern results from an
equidistant spacing of dots.  Approximating this requires
sophisticated algorithms.  We use a fairly simple algorithm known as
error diffusion, with certain modifications.


We currently have four dithering functions:

1) dither_black produces a single level of black from grayscale input.
   This is used by most printers when printing grayscale.

2) dither_cmyk produces 3, 4, 6, or 7 color output (actually, it can
   deal with any combination of dark and light colored inks, but not a
   "light black" ink, although that would be nice :-) ).

3) dither_black_n produces n levels of black.  This was originally
   written by Mike Sweet for various HP printers, but it's useful for
   some of the newer Epson Stylus printers, too.  Used for variable dot
   size or multi-level inks such as the MIS archival inks.

4) dither_cmyk_n does likewise for color output.

Many of these routines (in particular dither_cmyk and the 4-level functions)
have constants hard coded that are tuned for particular printers.  Needless
to say, this must go.

The dithering algorithm is a basic error diffusion, with a few tweaks of
my own.  Error diffusion works by taking the output error at a given pixel
and "diffusing" it into surrounding pixels.  Output error is the difference
between the amount of ink output and the input level at each pixel.  For
simple printers, with one or four ink colors and only one dot size, the
amount of ink output is either 65536 (i. e. full output) or 0 (no output).
The difference between this and the input level is the error.  Normal
error diffusion adds part of this error to the adjoining pixels in the
next column and the next row (the algorithm simply scans each row in turn,
never backing up).  The error adds up until it reaches a threshold (half of
the full output level, or 32768), at which point a dot is output, the
output is subtracted from the current value, and the (now negative) error
is diffused similarly.

Handling multiple output levels makes life a bit more complicated.  In
principle, it shouldn't be much harder: simply figure out what the ratio
between the available output levels is and have multiple thresholds.
In practice, getting these right involves a lot of trial and error.  The
other thing that's important is to maximize the number of dots that have
some ink.  This will reduce the amount of speckling.  More on this later.

The next question: how do we handle black when printing in color?  Black
ink is much darker than colored inks.  It's possible to produce black by
adding some mixture of cyan, magenta, and yellow -- in principle.  In
practice, the black really isn't very black, and different inks and
different papers will produce different color casts.  However, by using
CMY to produce gray, we can output a lot more dots!  This makes for a much
smoother image.  What's more, one cyan, one magenta, and one yellow dot
produce less darkness than one black dot, so we're outputting that many
more dots.  Better yet, with 6 or 7 color printers, we have to output even
more light ink dots.  So Epson Stylus Photo printers can produce really
smooth grays -- if we do everything right.  The right idea is to use
CMY at lower black levels, and gradually mix in black as the overall
amount of ink increases, so the black dots don't really become visible
within the ink mass.

I stated earlier that I've tweaked the basic error diffusion algorithm.
Here's what I've done to improve it:

1) We use a randomized threshold to decide when to print.  This does
   two things for us: it reduces the slightly squiggly diagonal lines
   that are the mark of error diffusion; and it allows us to lay down
   some ink even in very light areas near the edge of the image.
   The squiggly lines that error diffusion algorithms tend to generate
   are caused by the gradual accumulation of error.  This error is
   partially added horizontally and partially vertically.  The horizontal
   accumulation results in a dot eventually being printed.  The vertical
   accumulation results in a dot getting laid down in roughly the same
   horizontal position in the next row.  The diagonal squigglies result
   from the error being added to pixels one forward and one below the
   current pixel; these lines slope from the top right to the bottom left
   of the image.

   Error diffusion also results in pale areas being completely white near
   the top left of the image (the origin of the printing coordinates).
   This is because enough error has to accumulate for anything at all to
   get printed.  In very pale areas it takes quite a long time to
   build up anything printable at all; this results in the bare spots.

   Randomizing the threshold somewhat breaks up the diagonals to some
   degree by randomizing the exact location that the accumulated output
   crosses the threshold.  It reduces the false white areas by allowing
   some dots to be printed even when the accumulated output level is very
   low.  It doesn't result in excess ink because the full output level
   is still subtracted and diffused.

2) Alternating scan direction between rows (first row is scanned left to
   right, second is scanned right to left, and so on).  This also helps
   break up white areas, and it also seems to break up squigglies a bit.
   Furthermore, it eliminates directional biases in the horizontal
   direction.

3) Diffusing the error into more pixels.  Instead of diffusing the entire
   error into (X+1, Y) and (X, Y+1), we diffuse it into (X+1, Y),
   (X+K, Y+1), (X, Y+1), (X-K, Y+1) where K depends upon the output level
   (it never exceeds about 5 dots, and is greater at higher output
   levels).  This really reduces squigglies and graininess.

4) Don't lay down any colored ink if we're laying down black ink.  There's
   no point; the colored ink won't show.  We still pretend that we did
   for purposes of error diffusion (otherwise excessive error will build
   up, and will take a long time to clear, resulting in heavy bleeding of
   ink into surrounding areas, which is very ugly indeed), but we don't
   bother wasting the ink.

5) Oversampling.  This is how to print 1440x720 with Epson Stylus printers.
   Printing full density at 1440x720 will result in excess ink being laid
   down.  The trick is to print only every other dot.  We still compute
   the error as though we printed every dot.  It turns out that
   randomizing which dots are printed results in very speckled output.

What about multiple output levels?  For 6 and 7 color printers, simply
using different threshold levels has a problem: the pale inks have trouble
being seen when a lot of darker ink is being printed.  So rather than
just using the output level of the particular color to decide which ink
to print, we look at the total density (sum of all output levels).
If the density's high enough, we prefer to use the dark ink.  Speckling
is less visible when there's a lot of ink, anyway.  I haven't yet figured
out what to do for multiple levels of one color.

Speaking of 6 colors a bit more, I also determined (empirically!) that
simply subtracting the appropriate output level (full for the dark ink,
partial for the light ink) results in speckling.  Why?  Well, after printing
a dark dot, it takes longer to "recharge" the output level than after
printing a light dot.  What I do instead is compute a probability of
printing either a light or a dark dot when I exceed the threshold.  Picking
a random number decides which color ink to lay down.  However, rather than
subtracting the level appropriate for what I printed, I subtract a scaled
amount between the two levels.  The amount is scaled by the probability:
(L + P(D - L)) where L is the light level, P is the probability of
printing dark, D is the dark level.  This also results in smoother output.

You'll note that I haven't quoted a single source on color or printing
theory.  I simply did all of this empirically.

There are various other tricks to reduce speckling.  One that I've seen
is to reduce the amount of ink printed in regions where one color
(particularly cyan, which is perceived as the darkest) is very pale.
This does reduce speckling all right, but it also results in strange
tonal curves and weird (to my eye) colors.

Another, better trick is to print fixed patterns corresponding to given
output levels (basically a patterned screen).  This is probably much
better, but it's harder to get right in areas of rapidly varying color
and probably requires more lookup tables.  But it might be worth a
shot.


Before any dither routine is used, init_dither() must be called.  This
takes three arguments: the input width (number of pixels in the
input), the output width (number of pixels in the output), and
"overdensity".  If the inter-pixel spacing is less than the size of a
pixel, this can be set to that factor, in which case some of the
output pixels that would be printed are skipped.  This must be 1, 2,
4, or 8.  For example, the Epson Stylus printers that are capable of
1440 dpi are really 720 dpi printers that can position the print head
to 1/1440".  If nothing is done to correct for it, use of 1440 dpi
will result in twice as much ink being laid down as should be,
creating a dark image with heavy ink bleed-through.  There is an
alternative way to handle this; see scale_dither() below.

init_dither() returns a pointer to an opaque object representing the
dither.  This object is passed as the first argument to all of the
dither-related routines.

After a page is fully dithered, free_dither() must be called to free
the dither object and perform any cleanup.  In the future, this may do
more (such as flush output).  This arrangement permits using these
routines with programs that create multiple output pages, such as
GhostScript.

The dithering routines themselves have a number of control knobs that
control internal aspects of the dithering process.  These knobs are
accessible via a number of functions that can be called after
init_dither().

dither_set_black_lower() takes a double that should be between 0 and 1
   that represents the lowest density level at which black ink will
   start to mix in with colored ink to generate grays.  The lower this
   is, the less density is required to use black ink.  Setting this
   too low will result in speckling from black dots, particularly on 6
   and 7 color printers.  Setting this too high will make it hard to
   get satisfactory black or may result in sharp transition between
   blended colors and black.  Default: 0.0468.

   It is important to note that since the density scale is never
   linear (and since this value is adjusted via other things happening
   during the dithering process) that this does not mean that 95% gray
   will use any black ink.  At this setting, there will be no black
   ink used until about 50% gray.

   This only applies to color mode.

   This value should be set lower for printers capable of variable dot
   size, since more dots can be laid down close to each other.


dither_set_black_upper() takes a double that should be between 0 and 1
   that represents the highest density level at which colored inks
   will be mixed to create gray.  Setting this too low will result in
   speckly dark grays because there is not enough ink to fill all the
   holes, or sharp transition between blended colors and black if it
   is too close to the value of dither_set_black_upper().  Setting
   this too high will result in poor black and dark tone quality.
   Default: 0.5.  This results in 10% and darker grays being printed
   with essentially all black.

   This only applies to color mode.


dither_set_black_levels() takes three doubles that represent the
   amount of cyan, magenta, and yellow respectively that are blended
   to create gray.  The defaults are 1.0 for each, which is probably
   too low for most printers.  These values are adjusted to create a
   good gray balance.  Setting these too low will result in pale light
   and midtone grays, with a sharp transition to darker tones as black
   mixes in.  Setting them too high will result in overly dark grays
   and use of too much ink, possibly creating bleed-through.

   This only applies to color mode.


dither_set_randomizers() takes four integer values representing the
   degree of randomness used for cyan, magenta, yellow, and black.
   This is used to allow some printing to take place in pale areas.
   Zero is the most random; greater than 8 or so gives very little
   randomness at all.  Defaults are 0 for cyan, magenta, and yellow,
   and 4 for black.  Setting the value for black too low will result
   in black speckling in pale areas.  Setting values too high will
   result in pale areas getting no ink at all.

   This currently only applies to single dot size in color and black.
   It should be extended to operate in variable dot size mode,
   although actually applying it correctly will be tricky.


dither_set_ink_darkness() takes three doubles representing the
   contribution to perceived darkness of cyan, magenta, and yellow.
   This is used to help decide when to switch between light and dark
   inks in 6 and 7 color printers (with light cyan, light magenta, and
   possibly light yellow).  Setting these too low will result in too
   much light ink being laid down, creating flat spots in the darkness
   curves and bleed-through.  Setting them too high will result in
   dark ink being used in pale areas, creating speckle.  The defaults
   are .344 for cyan, .25 for magenta, and .156 for yellow.  Dark cyan
   will show against yellow much more than dark magenta will show
   against cyan, since the cyan appears much darker than the yellow.

   This only applies to 6 and 7 color printers in color mode.


dither_set_light_inks() takes three doubles between 0 and 1
   representing the ratio in darkness between the light and dark
   versions of the inks.  Setting these too low will result in too
   much dark ink being used in pale areas, creating speckling, while
   setting them too high will result in very smooth texture but too
   much use of light ink, resulting in flat spots in the density
   curves and ink bleed-through.  The defaults are .375 for each ink.

   This only applies to 6 and 7 color printers in single dot size
   color mode, and only to those inks which have light versions
   (usually cyan and magenta).


dither_set_c_levels()
dither_set_lc_levels()
dither_set_m_levels()
dither_set_lm_levels()
dither_set_y_levels()
dither_set_ly_levels()
dither_set_k_levels() each take an array of doubles representing the
   darkness values of each different dot size of each different ink.
   The first argument to each function is the number of levels, and
   the second argument is the array.  Normally, the first value should
   be 0 (no ink) and the last value should be 1.  Incorrect values of
   the intermediate elements will result in sharp transitions.  The
   defaults for each are four values of 0, .5, .83, and 1.0.  The
   values in the array are copied to local storage.

   This applies to variable dot size as appropriate.


scale_dither() is an alternative way of handling overdensity as
   described above.  Use of this function requires scaling the density
   on the input side appropriately.  The argument to scale_dither must
   be 1, 2, 4, or 8 (the input density must be divided by 1, 2, 4, or
   8 as appropriate).

   Depending upon the parameters chosen, this may create a smoother or
   more pleasing dither.  Setting this to 4 or 8, however, may result
   in too much ink being laid down and/or unusual dithering patterns.
   This may be due to a bug.  It should be possible to use this in
   conjunction with the horizontal_overdensity setting of
   init_dither(), but the product of the argument to this and the
   overdensity must still be 1, 2, 4, or 8.

-- Robert Krawitz <rlk@alum.mit.edu> March 8, 2000
