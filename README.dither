The dithering code in print-dither.c attempts to reproduce various
shades of gray (or all colors) from only a few different inks (black,
cyan, magenta, yellow, and sometimes light cyan and light magenta).
The dots can't vary in darkness or size (except for certain special
printers), and so we need to lay down a certain fraction of dots to
represent each distinct level.

This sounds straightforward; in practice, it isn't.  Completely random
distribution of dots (simple probabilistic dithering) would create
grainy clumps and light spots.  The smoothest pattern results from an
equidistant spacing of dots.  Approximating this requires
sophisticated algorithms.  We have two dithering algorithms, an
ordered dither algorithm that uses a grid (matrix) to decide whether
to print, and a modified Floyd-Steinberg error diffusion algorithm
that uses a grid in a slightly different way.


We currently have three dithering functions:

1) dither_fastblack produces pure black or white from a pre-dithered
   input.  This is used for two purposes: for printing pure black and
   white very quickly (e. g. text), and for printing pre-screened
   monochrome output that was rasterized externally.

2) dither_black produces black from grayscale input.  The new
   dither_black can produce either a single or multiple levels of
   black, for printers supporting variable dot size.

3) dither_cmyk produces 3, 4, 5, 6, or 7 color output (CMY, CMYK,
   CcMmYK, CcMmYy, CcMmYyK, or any variants).  The new routine can
   handle single or multiple levels of each color.

The dithering algorithm is a basic error diffusion, with a few tweaks of
my own.  Error diffusion works by taking the output error at a given pixel
and "diffusing" it into surrounding pixels.  Output error is the difference
between the amount of ink output and the input level at each pixel.  For
simple printers, with one or four ink colors and only one dot size, the
amount of ink output is either 65536 (i. e. full output) or 0 (no output).
The difference between this and the input level is the error.  Normal
error diffusion adds part of this error to the adjoining pixels in the
next column and the next row (the algorithm simply scans each row in turn,
never backing up).  The error adds up until it reaches a threshold (half of
the full output level, or 32768), at which point a dot is output, the
output is subtracted from the current value, and the (now negative) error
is diffused similarly.

Handling multiple output levels makes life a bit more complicated.  In
principle, it shouldn't be much harder: simply figure out what the ratio
between the available output levels is and have multiple thresholds.
In practice, getting these right involves a lot of trial and error.  The
other thing that's important is to maximize the number of dots that have
some ink.  This will reduce the amount of speckling.  More on this later.

The next question: how do we handle black when printing in color?  Black
ink is much darker than colored inks.  It's possible to produce black by
adding some mixture of cyan, magenta, and yellow -- in principle.  In
practice, the black really isn't very black, and different inks and
different papers will produce different color casts.  However, by using
CMY to produce gray, we can output a lot more dots!  This makes for a much
smoother image.  What's more, one cyan, one magenta, and one yellow dot
produce less darkness than one black dot, so we're outputting that many
more dots.  Better yet, with 6 or 7 color printers, we have to output even
more light ink dots.  So Epson Stylus Photo printers can produce really
smooth grays -- if we do everything right.  The right idea is to use
CMY at lower black levels, and gradually mix in black as the overall
amount of ink increases, so the black dots don't really become visible
within the ink mass.

Variable dot sizes are handled by dividing the range between 0 and
65536 into segments.  Each segment can either represent a range in
which all of one kind of ink (color and/or dot size) is used, with
varying amounts of ink, or a transition region between inks, in which
equal numbers of dots are printed but the amount of each ink will be
adjusted throughout the range.  Each range is represented by four
numbers:

1) bottom of the range
2) top of the range
3) value of the lighter ink
4) value of the darker ink

In addition, the bit patterns and which type of ink are also
represented, but they don't affect the actual algorithm.

The basic algorithm is the same whether we use ordered dither or error
diffusion.  We perform the following steps on each color of each pixel:

1) Compute the value of the particular color we're printing.  This
   isn't usually the pure CMY value; it's adjusted to improve
   saturation and to limit the use of black in light toned regions (to
   avoid speckling).

2) Find the range containing this value.

3) Compute where this value lies within the range.  We scale the
   endpoints between 0 and 65536 for this purpose.  So for example, if
   the bottom of the range is 10,000 and the top of the range is
   20,000, and the value is 12,500, we're 1/4 of the way between the
   bottom and the top of the range, so our scale point is 16384.

4) Compute the "virtual value".  The virtual value is the distance
   between the value of the lighter and the value of the darker ink.
   So if the value of the light ink is 32768 and the dark ink is
   65536, we compute a virtual value scaled appropriately between
   these two values, which is 40960 in this case.

5) Using either error diffusion or ordered dither, the standard
   threshold is 1/2 of the value (20480 in this case).  Using ordered
   dither, we want to compute a value between 0 and 40960 that we will
   compare the input value against to decide whether to print.  Using
   pure error diffusion, we would compare the accumulated error
   against 20480 to decide whether to print.  In practice, we use the
   same matrix method to decide whether to print.  The correct amount
   of ink will be printed this way, but we minimize the squiggly lines
   characteristic of error diffusion by dithering the threshold in
   this fashion.  A future enhancement will allow us to control the
   amount of dithering applied to the threshold.

How do we generate the matrix?  We actually use three matrices, for
reasons that will be explained below.  The first matrix was devised by
Bayer using a recurrence relation developed by Judice, Jarvis, and
Ninke, referenced at http://www.cs.rit.edu/~sxc7922/Project/CRT.htm.
This is a matrix of order 2 that is recursively (or, in our case,
iteratively) expanded to a higher order to yield a smoother dither
(order 2, with only 4 points, would not yield a very useful dither
matrix).  We scale it to order-128, or 16384 points.  This is the
smoothest possible matrix, in terms of ink per unit area and high
spatial frequencies.  Unfortunately, the dominant spatial frequency
along rows and columns is exactly 1/2 of the distance between points,
and the dominant spatial frequency along diagonals is zero!  This
yields very strong patterning.  This can be defeated to some extent by
adding a fraction of the row value to the column value and vice versa,
but that introduces other artifacts.  Nonetheless, this matrix is
useful.

The second matrix is based on an order-3 magic square, with the same
expansion up to order-81.  Magic squares have the property that the
sum along any row or any column is equal.  This means that the same
amount of ink is printed along any row or any column, which should
yield a smooth result.  The spatial frequencies are lower than the
iterated order-2 matrix, and the dots are a bit clumpier, but the
patterns are less linear.  It does generate other patterns, though.

The third matrix is based on a family of super-magic squares taken
from
http://www.pse.che.tohoku.ac.jp/~msuzuki/MagicSquare.5x5.selfsim.html.
In addition to the usual row and column, and almost as usual diagonals
(major and minor), squares in this family are also self-complementary,
and there are other patterns within the square that are magic.  These
squares are order-5.  I have picked a couple that look relatively well
distributed.  This square is iterated up to order 125.  This square
generates output that is very smooth in some ways.

There are many other dither matrices available.  Many of them are
patented.  The Bayer matrix, and the recurrence relation used to
generate it, was described in 1974 or earlier, so it is clearly out of
patent.  I am not aware of patents on the use of any of the other
matrices used in this work.  Matrices could be generated in other
ways, such as blue noise (noise with predominantly high frequencies,
as opposed to white noise, with a flat spectrum, or pink noise, with
predominantly low frequencies) or fractals.

What we actually do, to smooth out the patterns, is to use parts of
multiple dither matrices in order to generate a super-matrix of very
high order and with many different spatial frequencies, mostly high
ones.  I haven't proved that this generates a good spectrum, but
visually it seems to.

Actually, it's essential to use different matrices for deciding
whether to print and for deciding what color to print.  This should be
obvious; the decision about what color to print should be as
independent as possible from the decision about what color to print.
Actually, that's almost true; we don't want too many low frequencies
introduced.

How do we compute the ranges?  That's actually surprisingly
complicated.

The matrices I ultimately chose are as follows:

1) With error diffusion, I use the iterated-3 matrix xored with the
   iterated-5 matrix shifted right two bits to decide whether to
   print.  So the high order bits come from the iterated-3 matrix, the
   middle order bits come from both, and the lowest order bits come
   from the iterated-5 matrix.  This seems to break up the patterns of
   the iterated-3 matrix.  To decide what to print, I use the pure
   iterated-5 matrix.  This is theoretically not very sound, but
   in practice it seems to yield a good mix.  The two bit shift was
   derived empirically; shifting right by three bits yielded too much
   of a range dominated by the iterated-3 matrix, while shifting right
   by one bit caused problems with the choice of ink color.

2) With ordered dither, I use the iterated-2 matrix sheared in both
   the x and y direction to decide whether to print, and the
   iterated-5 matrix to decide what to print.

A final note about the matrices is that I should use different offsets
with each color, to avoid too much overprinting and blank spots.  The
choice of offset may be important; I'm tempted to use 7 places (which
is relatively prime with 2, 3, and 5).


I stated earlier that I've tweaked the basic error diffusion algorithm.
Here's what I've done to improve it:

1) We use a variable threshold to decide when to print, as discussed
   above.  This does two things for us: it reduces the slightly
   squiggly diagonal lines that are the mark of error diffusion; and
   it allows us to lay down some ink even in very light areas near the
   edge of the image.  The squiggly lines that error diffusion
   algorithms tend to generate are caused by the gradual accumulation
   of error.  This error is partially added horizontally and partially
   vertically.  The horizontal accumulation results in a dot
   eventually being printed.  The vertical accumulation results in a
   dot getting laid down in roughly the same horizontal position in
   the next row.  The diagonal squigglies result from the error being
   added to pixels one forward and one below the current pixel; these
   lines slope from the top right to the bottom left of the image.

   Error diffusion also results in pale areas being completely white near
   the top left of the image (the origin of the printing coordinates).
   This is because enough error has to accumulate for anything at all to
   get printed.  In very pale areas it takes quite a long time to
   build up anything printable at all; this results in the bare spots.

   Randomizing the threshold somewhat breaks up the diagonals to some
   degree by randomizing the exact location that the accumulated output
   crosses the threshold.  It reduces the false white areas by allowing
   some dots to be printed even when the accumulated output level is very
   low.  It doesn't result in excess ink because the full output level
   is still subtracted and diffused.

2) Alternating scan direction between rows (first row is scanned left to
   right, second is scanned right to left, and so on).  This also helps
   break up white areas, and it also seems to break up squigglies a bit.
   Furthermore, it eliminates directional biases in the horizontal
   direction.  This isn't necessary for ordered dither, but it doesn't
   hurt anything either.

3) Diffusing the error into more pixels.  Instead of diffusing the entire
   error into (X+1, Y) and (X, Y+1), we diffuse it into (X+1, Y),
   (X+K, Y+1), (X, Y+1), (X-K, Y+1) where K depends upon the output level
   (it never exceeds about 10 dots, and is greater at higher output
   levels).  This really reduces squigglies and graininess.  The
   amount of this spread can be controlled; for line art, it should be
   less than for photographs (of course, line art doesn't usually
   contain much light color, but the ERROR value can be small in places!)

4) Don't lay down any colored ink if we're laying down black ink.  There's
   no point; the colored ink won't show.  We still pretend that we did
   for purposes of error diffusion (otherwise excessive error will build
   up, and will take a long time to clear, resulting in heavy bleeding of
   ink into surrounding areas, which is very ugly indeed), but we don't
   bother wasting the ink.  How well this will do with variable dot
   size remains to be seen.

5) Oversampling.  This is how to print 1440x720 with Epson Stylus printers.
   Printing full density at 1440x720 will result in excess ink being laid
   down.  The trick is to print only every other dot.  We still compute
   the error as though we printed every dot.  It turns out that
   randomizing which dots are printed results in very speckled
   output.  This can be taken too far; oversampling at 1440x1440 or
   2880x720 virtual resolution results in other problems.

What about multiple output levels?  For 6 and 7 color printers, simply
using different threshold levels has a problem: the pale inks have trouble
being seen when a lot of darker ink is being printed.  So rather than
just using the output level of the particular color to decide which ink
to print, we look at the total density (sum of all output levels).
If the density's high enough, we prefer to use the dark ink.  Speckling
is less visible when there's a lot of ink, anyway.  I haven't yet figured
out what to do for multiple levels of one color.

Speaking of 6 colors a bit more, I also determined (empirically!) that
simply subtracting the appropriate output level (full for the dark ink,
partial for the light ink) results in speckling.  Why?  Well, after printing
a dark dot, it takes longer to "recharge" the output level than after
printing a light dot.  What I do instead is compute a probability of
printing either a light or a dark dot when I exceed the threshold.  Picking
a random number decides which color ink to lay down.  However, rather than
subtracting the level appropriate for what I printed, I subtract a scaled
amount between the two levels.  The amount is scaled by the probability:
(L + P(D - L)) where L is the light level, P is the probability of
printing dark, D is the dark level.  This also results in smoother output.

You'll note that I haven't quoted a single source on color or printing
theory.  I simply did all of this empirically.

There are various other tricks to reduce speckling.  One that I've seen
is to reduce the amount of ink printed in regions where one color
(particularly cyan, which is perceived as the darkest) is very pale.
This does reduce speckling all right, but it also results in strange
tonal curves and weird (to my eye) colors.

Another, better trick is to print fixed patterns corresponding to given
output levels (basically a patterned screen).  This is probably much
better, but it's harder to get right in areas of rapidly varying color
and probably requires more lookup tables.  But it might be worth a
shot.


Before any dither routine is used, init_dither() must be called.  This
takes three arguments: the input width (number of pixels in the
input), the output width (number of pixels in the output), and
"overdensity".  If the inter-pixel spacing is less than the size of a
pixel, this can be set to that factor, in which case some of the
output pixels that would be printed are skipped.  This must be 1, 2,
4, or 8.  For example, the Epson Stylus printers that are capable of
1440 dpi are really 720 dpi printers that can position the print head
to 1/1440".  If nothing is done to correct for it, use of 1440 dpi
will result in twice as much ink being laid down as should be,
creating a dark image with heavy ink bleed-through.  There is an
alternative way to handle this; see scale_dither() below.

init_dither() returns a pointer to an opaque object representing the
dither.  This object is passed as the first argument to all of the
dither-related routines.

After a page is fully dithered, free_dither() must be called to free
the dither object and perform any cleanup.  In the future, this may do
more (such as flush output).  This arrangement permits using these
routines with programs that create multiple output pages, such as
GhostScript.

The dithering routines themselves have a number of control knobs that
control internal aspects of the dithering process.  These knobs are
accessible via a number of functions that can be called after
init_dither().

dither_set_black_lower() takes a double that should be between 0 and 1
   that represents the lowest density level at which black ink will
   start to mix in with colored ink to generate grays.  The lower this
   is, the less density is required to use black ink.  Setting this
   too low will result in speckling from black dots, particularly on 6
   and 7 color printers.  Setting this too high will make it hard to
   get satisfactory black or may result in sharp transition between
   blended colors and black.  Default: 0.0468.

   It is important to note that since the density scale is never
   linear (and since this value is adjusted via other things happening
   during the dithering process) that this does not mean that 95% gray
   will use any black ink.  At this setting, there will be no black
   ink used until about 50% gray.

   This only applies to color mode.

   This value should be set lower for printers capable of variable dot
   size, since more dots can be laid down close to each other.


dither_set_black_upper() takes a double that should be between 0 and 1
   that represents the highest density level at which colored inks
   will be mixed to create gray.  Setting this too low will result in
   speckly dark grays because there is not enough ink to fill all the
   holes, or sharp transition between blended colors and black if it
   is too close to the value of dither_set_black_upper().  Setting
   this too high will result in poor black and dark tone quality.
   Default: 0.5.  This results in 10% and darker grays being printed
   with essentially all black.

   This only applies to color mode.


dither_set_black_levels() takes three doubles that represent the
   amount of cyan, magenta, and yellow respectively that are blended
   to create gray.  The defaults are 1.0 for each, which is probably
   too low for most printers.  These values are adjusted to create a
   good gray balance.  Setting these too low will result in pale light
   and midtone grays, with a sharp transition to darker tones as black
   mixes in.  Setting them too high will result in overly dark grays
   and use of too much ink, possibly creating bleed-through.

   This only applies to color mode.


dither_set_randomizers() takes four integer values representing the
   degree of randomness used for cyan, magenta, yellow, and black.
   This is used to allow some printing to take place in pale areas.
   Zero is the most random; greater than 8 or so gives very little
   randomness at all.  Defaults are 0 for cyan, magenta, and yellow,
   and 4 for black.  Setting the value for black too low will result
   in black speckling in pale areas.  Setting values too high will
   result in pale areas getting no ink at all.

   This currently only applies to single dot size in color and black.
   It should be extended to operate in variable dot size mode,
   although actually applying it correctly will be tricky.


dither_set_ink_darkness() takes three doubles representing the
   contribution to perceived darkness of cyan, magenta, and yellow.
   This is used to help decide when to switch between light and dark
   inks in 6 and 7 color printers (with light cyan, light magenta, and
   possibly light yellow).  Setting these too low will result in too
   much light ink being laid down, creating flat spots in the darkness
   curves and bleed-through.  Setting them too high will result in
   dark ink being used in pale areas, creating speckle.  The defaults
   are .344 for cyan, .25 for magenta, and .156 for yellow.  Dark cyan
   will show against yellow much more than dark magenta will show
   against cyan, since the cyan appears much darker than the yellow.

   This only applies to 6 and 7 color printers in color mode.


dither_set_light_inks() takes three doubles between 0 and 1
   representing the ratio in darkness between the light and dark
   versions of the inks.  Setting these too low will result in too
   much dark ink being used in pale areas, creating speckling, while
   setting them too high will result in very smooth texture but too
   much use of light ink, resulting in flat spots in the density
   curves and ink bleed-through.  The defaults are .375 for each ink.

   This only applies to 6 and 7 color printers in single dot size
   color mode, and only to those inks which have light versions
   (usually cyan and magenta).

dither_set_ink_spread() takes a small integer representing the amount
   of ink spread in the dither.  Larger numbers mean less spread.
   Larger values are appropriate for line art and solid tones; they
   will yield sharper transitions but more dither artifacts.  Smaller
   values are more appropriate for photos.  They will reduce
   resolution and sharpness but reduce dither artifacts up to a
   point.  A value of 19 or higher implies minimum ink spread at any
   resolution no matter what the overdensity.  A value of 14 is
   typical for photos.


dither_set_c_levels()
dither_set_lc_levels()
dither_set_m_levels()
dither_set_lm_levels()
dither_set_y_levels()
dither_set_ly_levels()
dither_set_k_levels() each take an array of doubles representing the
   darkness values of each different dot size of each different ink.
   The first argument to each function is the number of levels, and
   the second argument is the array.  Normally, the first value should
   be 0 (no ink) and the last value should be 1.  Incorrect values of
   the intermediate elements will result in sharp transitions.  The
   defaults for each are four values of 0, .5, .83, and 1.0.  The
   values in the array are copied to local storage.

   This applies to variable dot size as appropriate.


scale_dither() is an alternative way of handling overdensity as
   described above.  Use of this function requires scaling the density
   on the input side appropriately.  The argument to scale_dither must
   be 1, 2, 4, or 8 (the input density must be divided by 1, 2, 4, or
   8 as appropriate).

   Depending upon the parameters chosen, this may create a smoother or
   more pleasing dither.  Setting this to 4 or 8, however, may result
   in too much ink being laid down and/or unusual dithering patterns.
   This may be due to a bug.  It should be possible to use this in
   conjunction with the horizontal_overdensity setting of
   init_dither(), but the product of the argument to this and the
   overdensity must still be 1, 2, 4, or 8.

-- Robert Krawitz <rlk@alum.mit.edu> March 8, 2000
