/*
 *  $Id: gimp-print.h.in,v 1.17 2002/11/13 22:42:27 rleigh Exp $
 *
 *   Print plug-in header file for the GIMP.
 *
 *   Copyright 1997-2000 Michael Sweet (mike@easysw.com) and
 *      Robert Krawitz (rlk@alum.mit.edu)
 *
 *   This program is free software; you can redistribute it and/or modify it
 *   under the terms of the GNU General Public License as published by the Free
 *   Software Foundation; either version 2 of the License, or (at your option)
 *   any later version.
 *
 *   This program is distributed in the hope that it will be useful, but
 *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 *   for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 * Revision History:
 *
 *   See ChangeLog
 */

/*
 * This file must include only standard C header files.  The core code must
 * compile on generic platforms that don't support glib, gimp, gtk, etc.
 */

#ifndef __GIMP_PRINT_H__
#define __GIMP_PRINT_H__

/*
 * Include necessary header files...
 */

#include <stddef.h>     /* For size_t */

#ifdef __cplusplus
extern "C" {
#endif


/*
 * Library versioning details
 */

/*
 * compile-time version
 */
#define GIMPPRINT_MAJOR_VERSION       (@GIMPPRINT_MAJOR_VERSION@)
#define GIMPPRINT_MINOR_VERSION       (@GIMPPRINT_MINOR_VERSION@)
#define GIMPPRINT_MICRO_VERSION       (@GIMPPRINT_MICRO_VERSION@)
#define GIMPPRINT_CURRENT_INTERFACE   (@GIMPPRINT_CURRENT_INTERFACE@)
#define GIMPPRINT_BINARY_AGE          (@GIMPPRINT_BINARY_AGE@)
#define GIMPPRINT_INTERFACE_AGE       (@GIMPPRINT_INTERFACE_AGE@)
#define GIMPPRINT_CHECK_VERSION(major,minor,micro) \
  (GIMPPRINT_MAJOR_VERSION >  (major) || \
  (GIMPPRINT_MAJOR_VERSION == (major) && GIMPPRINT_MINOR_VERSION > (minor)) || \
  (GIMPPRINT_MAJOR_VERSION == (major) && GIMPPRINT_MINOR_VERSION == (minor) && \
   GIMPPRINT_MICRO_VERSION >= (micro)))

extern const unsigned int gimpprint_major_version;
extern const unsigned int gimpprint_minor_version;
extern const unsigned int gimpprint_micro_version;
extern const unsigned int gimpprint_current_interface;
extern const unsigned int gimpprint_binary_age;
extern const unsigned int gimpprint_interface_age;
extern const char* stp_check_version(unsigned int required_major,
				     unsigned int required_minor,
				     unsigned int required_micro);


/*
 * Constants...
 */

#define OUTPUT_GRAY             0       /* Grayscale output */
#define OUTPUT_COLOR            1       /* Color output */
#define OUTPUT_MONOCHROME       2       /* Raw monochrome output */
#define OUTPUT_RAW_CMYK         3       /* Raw CMYK output */
#define OUTPUT_RAW_PRINTER	4	/* Printer-specific raw output */

#define IMAGE_LINE_ART          0
#define IMAGE_SOLID_TONE        1
#define IMAGE_CONTINUOUS        2
#define NIMAGE_TYPES            3

#define COLOR_MODEL_RGB         0
#define COLOR_MODEL_CMY         1
#define NCOLOR_MODELS           2

/*
 * Printer driver control structure.  See "print.c" for the actual list...
 */

typedef enum stp_papersize_unit
{
  PAPERSIZE_ENGLISH,
  PAPERSIZE_METRIC
} stp_papersize_unit_t;

typedef enum stp_image_status
{
  STP_IMAGE_OK,
  STP_IMAGE_ABORT
} stp_image_status_t;

typedef enum stp_parameter_type
{
  STP_PARAMETER_TYPE_INVALID,
  STP_PARAMETER_TYPE_ENUM_STRING
} stp_parameter_type_t;

typedef enum stp_parameter_class
{
  STP_PARAMETER_CLASS_INVALID,
  STP_PARAMETER_CLASS_FEATURE,
  STP_PARAMETER_CLASS_OUTPUT,
  STP_PARAMETER_CLASS_PAGE_SIZE
} stp_parameter_class_t;

/*
 * Abstract data type for interfacing with the image creation program
 * (in this case, the Gimp).
 *
 * The progress_init(), note_progress(), and progress_conclude() members
 * are used to enable the image layer to deliver notification of
 * progress to the user.  It is likely that these functions will be
 * dropped in the future, and if desired must be implemented in
 * get_row().
 *
 * get_appname() should return the name of the application.  This is
 * embedded in the output by some drivers.
 *
 * width() and height() return the dimensions of the image in pixels.
 *
 * bpp(), or bytes per pixel, is used in combination with the output type
 * and presence of a color map, if supplied, to determine the format
 * of the input:
 *
 * Output_type is OUTPUT_MONOCHROME, OUTPUT_COLOR, or OUTPUT_GRAY:
 *
 *    bpp           No color map                Color map present
 *     1            grayscale                   indexed color (256 colors)
 *     2            grayscale w/alpha           indexed color w/alpha
 *     3            RGB                         N/A
 *     4            N/A                         RGB w/alpha (RGBA)
 *
 * Output_type is OUTPUT_CMYK:
 *
 *    bpp           No color map                Color map present
 *     4            8 bits/plane CMYK           N/A
 *     8            16 bits/plane CMYK          N/A
 *
 * Output type is OUTPUT_RAW_PRINTER:
 *
 *    If the printer supports OUTPUT_RAW_PRINTER, the bpp value should be
 *    2 x the number of channels desired to print (the precise modes
 *    available are printer-dependent).  Each plane is therefore 2 bytes
 *    (16 bits) deep.
 *
 * init() is used to perform any initialization required by the image
 * layer for the image.  It will be called once per image.  reset() is
 * called to reset the image to the beginning.  It may (in principle)
 * be called multiple times if a page is being printed more than once.
 * The reset() call may be removed in the future.
 *
 * get_row() transfers the data from the image to the gimp-print
 * library.  It is called from the driver layer.  It should copy WIDTH
 * (as returned by the width() member) pixels of data into the data
 * buffer.  It normally returns STP_IMAGE_OK; if something goes wrong,
 * or the application wishes to stop producing any further output
 * (e. g. because the user cancelled the print job), it should return
 * STP_IMAGE_ABORT.  This will cause the driver to flush any remaining
 * data to the output.  It will always request rows in monotonically
 * ascending order, but it may skip rows (if, for example, the
 * resolution of the input is higher than the resolution of the
 * output).
 */

typedef struct stp_image
{
  void (*init)(struct stp_image *image);
  void (*reset)(struct stp_image *image);
  int  (*bpp)(struct stp_image *image);
  int  (*width)(struct stp_image *image);
  int  (*height)(struct stp_image *image);
  stp_image_status_t (*get_row)(struct stp_image *image, unsigned char *data,
                                int row);
  const char *(*get_appname)(struct stp_image *image);
  void (*progress_init)(struct stp_image *image);
  void (*note_progress)(struct stp_image *image, double current, double total);
  void (*progress_conclude)(struct stp_image *image);
  void *rep;
} stp_image_t;

typedef void *stp_printer_t;
typedef void *stp_vars_t;
typedef void *stp_papersize_t;
  

typedef struct
{
  const char	*name,	/* Option name */
		*text;	/* Human-readable (translated) text */
} stp_param_t;

typedef void *stp_param_list_t;

typedef void (*stp_outfunc_t) (void *data, const char *buffer, size_t bytes);

/*
 *   Return a list of option values of the specified parameter NAME
 *   for the specified PRINTER.  The number of options returned is
 *   placed in COUNT.  Both the array and the options themselves are
 *   allocated on the heap; it is the caller's responsibility to free
 *   them upon completion of use.  The driver must therefore return a
 *   copy of data.
 *
 *   The data stored in V may be used to influence the values
 *   returned.  For example, a PPD file stored in V may be used by the
 *   driver.
 *
 *   The list of parameters is subject to change.  The currently supported
 *   parameters are:
 *
 *     PageSize returns a list of legal page size names for the printer
 *       in question.
 *
 *     Resolution returns a list of valid resolution settings.  The
 *       resolutions are to be interpreted as opaque names; the caller
 *       must not attempt to interpret them except with the
 *       describe_resolution function described below.  There may be
 *       multiple resolution names that resolve to the same printing
 *       resolution; they may correspond to different quality settings,
 *       for example.
 *
 *     InkType returns a list of legal ink types.  The printer driver may
 *       define these as it sees fit.  If a printer offers a choice of
 *       ink cartridges, the choices would be enumerated here.
 *
 *     MediaType returns a list of legal media types.  The printer driver
 *       may define these as it sees fit.  This is normally different kinds
 *       of paper that the printer can handle.
 *
 *     InputSlot returns a list of legal input sources for the printer.
 *       This is typically things like different input trays, manual feed,
 *       roll feed, and the like.
 */

extern stp_param_list_t
stp_printer_get_parameters(const stp_printer_t printer,
			   const stp_vars_t v,
			   const char *name);

/*
 * Return the default value for the specified parameter.
 */
extern const char *
stp_printer_get_default_parameter(const stp_printer_t printer,
				  const stp_vars_t v,
				  const char *name);

/*
 * Retrieve the media size of the media type set in V, expressed in units
 * of 1/72".  If the media size is invalid, width and height will be set
 * to -1.  Values of 0 for width or height indicate that the dimension
 * is variable, so that custom page sizes or roll paper can be used.
 * In this case, the size limit should be used to determine maximum and
 * minimum values permitted.
 */
extern void
stp_printer_get_media_size(const stp_printer_t printer,
			   const stp_vars_t v,
			   int *width,
			   int *height);

/*
 * Retrieve the boundaries of the printable area of the page.  In combination
 * with the media size, this can be used to determine the actual printable
 * region, which callers can use to place the image precisely.  The
 * dimensions are relative to the top left of the physical page.
 *
 * If a customizable page size is used (see stp_printer_get_media_size),
 * the actual desired width and/or height must be filled in using
 * stp_set_page_width and/or stp_set_page_height.  If these are not filled
 * in, the margins will be returned.
 *
 * Returned values may be negative if a printer is capable of full bleed
 * by printing beyond the physical boundaries of the page.
 *
 * If the media size stored in V is invalid, the return value
 * will be indeterminate.  It is up to the user to specify legal values.
 */
extern void
stp_printer_get_imageable_area(const stp_printer_t printer,
			       const stp_vars_t v,
			       int *left,
			       int *right,
			       int *bottom,
			       int *top);

/*
 * Retrieve the minimum and maximum size limits for custom media sizes.
 */
extern void
stp_printer_get_size_limit(const stp_printer_t printer,
			   const stp_vars_t v,
			   int *max_width,
			   int *max_height,
			   int *min_width,
			   int *min_height);

/*
 * Retrieve the printing resolution of the resolution stored in V.
 */
extern void
stp_printer_describe_resolution(const stp_printer_t printer,
				const stp_vars_t v,
				int *x,
				int *y);

/*
 * Verify that the parameters stored in V are consistent with those allowed
 * by the driver.  This must be called prior to printing; failure to do
 * so will result in printing failing.  Status of 0 represents failure;
 * status of 1 represents success; other status values are reserved.
 */
extern int
stp_printer_verify(const stp_printer_t printer,
		   const stp_vars_t v);

/*
 * Print the image.  Return value of 0 represents failure; status of 1
 * represents success; status of 2 represents abort requested by the driver.
 */
extern int
stp_print(const stp_printer_t printer,
	  const stp_vars_t v,
	  stp_image_t *image);

/*
 * stp_init() must be called prior to any other use of the library.
 */
extern int stp_init(void);

/*
 * Set the encoding that all translated strings are output in.
 */
extern const char * stp_set_output_codeset(const char *codeset);

extern const char * stp_printer_get_long_name(const stp_printer_t p);
extern const char * stp_printer_get_driver(const stp_printer_t p);
extern int stp_printer_get_model(const stp_printer_t p);
extern const stp_vars_t stp_printer_get_printvars(const stp_printer_t p);
extern void stp_set_printer_defaults(stp_vars_t, const stp_printer_t);

extern stp_param_list_t stp_param_list_allocate(void);
extern void stp_param_list_free(stp_param_list_t list);
extern stp_param_t *stp_param_list_param(const stp_param_list_t list,
					 size_t element);
extern size_t stp_param_list_count(const stp_param_list_t list);
extern stp_param_list_t stp_param_list_duplicate(const stp_param_list_t list);
extern stp_param_list_t stp_param_list_duplicate_params(const stp_param_t *list,
							size_t count);
extern void stp_param_list_add_param(stp_param_list_t list,
				     const char *name, const char *text);

extern stp_vars_t stp_allocate_vars(void);
extern void stp_copy_vars(stp_vars_t vd, const stp_vars_t vs);
extern stp_vars_t stp_allocate_copy(const stp_vars_t vs);

extern void stp_free_vars(stp_vars_t v);

extern void stp_set_driver(stp_vars_t v, const char *val);
extern void stp_set_driver_n(stp_vars_t v, const char *val, int bytes);

extern const char **stp_printer_list_parameters(const stp_printer_t printer,
						const stp_vars_t v,
						int *count);

extern stp_parameter_class_t
stp_printer_parameter_class(const stp_printer_t printer,
			    const stp_vars_t v,
			    const char *parameter_name);

extern stp_parameter_type_t
stp_printer_parameter_type(const stp_printer_t printer,
			   const stp_vars_t v,
			   const char *parameter_name);

extern void stp_set_parameter(stp_vars_t v, const char *parameter,
			      const char *value);
extern void stp_set_ppd_file(stp_vars_t v, const char *val);

extern void stp_set_parameter_n(stp_vars_t v, const char *parameter,
				const char *value, int bytes);
extern void stp_set_ppd_file_n(stp_vars_t v, const char *val, int bytes);

/*
 * The _n variants are used for strings that are not null-delimited.
 */

extern void stp_set_output_type(stp_vars_t v, int val);
extern void stp_set_left(stp_vars_t v, int val);
extern void stp_set_top(stp_vars_t v, int val);
extern void stp_set_width(stp_vars_t v, int val);
extern void stp_set_height(stp_vars_t v, int val);
extern void stp_set_image_type(stp_vars_t v, int val);
extern void stp_set_page_width(stp_vars_t v, int val);
extern void stp_set_page_height(stp_vars_t v, int val);

/*
 * Input color model refers to how the data is being sent to the
 * driver library; the default is RGB.  Output color model refers to
 * the characteristics of the device; the default is CMYK.  The output
 * color model is set by the printer driver and cannot be overridden.
 * It is provided to permit applications to generate previews using
 * the color machinery in Gimp-Print.  If this is done, normally
 * the output color model will be RGB.
 */
extern void stp_set_input_color_model(stp_vars_t v, int val);
extern void stp_set_output_color_model(stp_vars_t v, int val);

extern void stp_set_brightness(stp_vars_t v, float val);
extern void stp_set_gamma(stp_vars_t v, float val);
extern void stp_set_contrast(stp_vars_t v, float val);
extern void stp_set_cyan(stp_vars_t v, float val);
extern void stp_set_magenta(stp_vars_t v, float val);
extern void stp_set_yellow(stp_vars_t v, float val);
extern void stp_set_saturation(stp_vars_t v, float val);
extern void stp_set_density(stp_vars_t v, float val);

/*
 * Application gamma is used to initially correct the input data
 * for the application's characteristics.  This cannot be done by the
 * application (except in 16-bit CMYK mode) without losing data.
 */
extern void stp_set_app_gamma(stp_vars_t v, float val);

/*
 * Please see the source in print-color.c for an explanation of this.
 */
extern void stp_set_lut(stp_vars_t v, void * val);

/*
 * For use with indexed color: the LUT should be an array of 256
 * RGB values.
 */
extern void stp_set_cmap(stp_vars_t v, unsigned char * val);

/*
 * These functions are used to print output and diagnostic information
 * respectively.  These must be supplied by the caller.
 */
extern void stp_set_outfunc(const stp_vars_t v, stp_outfunc_t val);
extern void stp_set_errfunc(const stp_vars_t v, stp_outfunc_t val);
extern void stp_set_outdata(stp_vars_t v, void * val);
extern void stp_set_errdata(stp_vars_t v, void * val);

extern const char * stp_get_driver(const stp_vars_t v);

extern const char * stp_get_parameter(const stp_vars_t v, const char *param);
extern const char * stp_get_ppd_file(const stp_vars_t v);

extern int stp_get_output_type(const stp_vars_t v);
extern int stp_get_left(const stp_vars_t v);
extern int stp_get_top(const stp_vars_t v);
extern int stp_get_width(const stp_vars_t v);
extern int stp_get_height(const stp_vars_t v);
extern int stp_get_image_type(const stp_vars_t v);
extern int stp_get_page_width(const stp_vars_t v);
extern int stp_get_page_height(const stp_vars_t v);
extern int stp_get_input_color_model(const stp_vars_t v);
extern int stp_get_output_color_model(const stp_vars_t v);
extern float stp_get_brightness(const stp_vars_t v);
extern float stp_get_gamma(const stp_vars_t v);
extern float stp_get_contrast(const stp_vars_t v);
extern float stp_get_cyan(const stp_vars_t v);
extern float stp_get_magenta(const stp_vars_t v);
extern float stp_get_yellow(const stp_vars_t v);
extern float stp_get_saturation(const stp_vars_t v);
extern float stp_get_density(const stp_vars_t v);
extern float stp_get_app_gamma(const stp_vars_t v);
extern void * stp_get_lut(const stp_vars_t v);
extern stp_outfunc_t stp_get_outfunc(const stp_vars_t v);
extern stp_outfunc_t stp_get_errfunc(const stp_vars_t v);
extern void * stp_get_outdata(const stp_vars_t v);
extern void * stp_get_errdata(const stp_vars_t v);
extern unsigned char * stp_get_cmap(const stp_vars_t v);


/*
 * hue_map is an array of 49 doubles representing the mapping of hue
 * from (0..6) to (0..6) in increments of .125.  The hue_map is in CMY space,
 * so hue=0 is cyan.  Interpolation between values is linear.
 *
 * lum_map and sat_map are correction factors for luminosity and saturation
 * respectively.  Both of these are inverse exponential.  The degree of
 * luminosity correction is scaled by the saturation of the particular
 * pixel.  This is likely to change drastically in the future.
 */
typedef void (*stp_convert_t) (const stp_vars_t vars, const unsigned char *in,
                               unsigned short *out, int *zero_mask,
                               int width, int bpp, const unsigned char *cmap,
                               const double *hue_map, const double *lum_map,
                               const double *sat_map);

extern void stp_merge_printvars(stp_vars_t user, const stp_vars_t print);

extern int stp_known_papersizes(void);
extern const stp_papersize_t stp_get_papersize_by_name(const char *name);
extern const stp_papersize_t stp_get_papersize_by_size(int l, int w);
extern const stp_papersize_t stp_get_papersize_by_index(int index);
extern const char * stp_papersize_get_name(const stp_papersize_t pt);
extern const char * stp_papersize_get_text(const stp_papersize_t pt);
extern unsigned stp_papersize_get_width(const stp_papersize_t pt);
extern unsigned stp_papersize_get_height(const stp_papersize_t pt);
extern unsigned stp_papersize_get_top(const stp_papersize_t pt);
extern unsigned stp_papersize_get_left(const stp_papersize_t pt);
extern unsigned stp_papersize_get_bottom(const stp_papersize_t pt);
extern unsigned stp_papersize_get_right(const stp_papersize_t pt);
extern stp_papersize_unit_t stp_papersize_get_unit(const stp_papersize_t pt);


extern int stp_known_printers(void);
extern const stp_printer_t stp_get_printer_by_index(int idx);
extern const stp_printer_t stp_get_printer_by_long_name(const char *long_name);
extern const stp_printer_t stp_get_printer_by_driver(const char *driver);
extern int stp_get_printer_index_by_driver(const char *driver);

/*
 * This is likely to change in the future.
 */
extern stp_convert_t stp_choose_colorfunc(int output_type, int image_bpp,
					  const unsigned char *cmap,
					  int *out_bpp, const stp_vars_t v);
extern void stp_allocate_lut(stp_vars_t v, size_t steps);
extern void stp_free_lut(stp_vars_t v);
extern void stp_compute_lut(stp_vars_t v, size_t steps);

extern const stp_vars_t stp_default_settings(void);
extern const stp_vars_t stp_maximum_settings(void);
extern const stp_vars_t stp_minimum_settings(void);


/*
 * List functions
 */
typedef void stp_list_item_t;
typedef void stp_list_t;

void stp_list_node_free_data(stp_list_item_t *item);
stp_list_t *stp_list_create(void);
int stp_list_destroy(stp_list_t *list);
stp_list_item_t *stp_list_get_start(stp_list_t *list);
stp_list_item_t *stp_list_get_end(stp_list_t *list);
stp_list_item_t *stp_list_get_item_by_index(stp_list_t *list, int index);
stp_list_item_t *stp_list_get_item_by_name(stp_list_t *list, const char *name);
stp_list_item_t *stp_list_get_item_by_long_name(stp_list_t *list, const char *long_name);
int stp_list_get_length(stp_list_t *list);
void stp_list_set_freefunc(stp_list_t *list,
			   void (*node_freefunc)(stp_list_item_t *item));
void stp_list_set_namefunc(stp_list_t *list,
			   const char *(*namefunc)(const stp_list_item_t *item));
void stp_list_set_long_namefunc(stp_list_t *list,
				const char *(*long_namefunc)(const stp_list_item_t *item));
void stp_list_set_sortfunc(stp_list_t *list, 
			   int (*sortfunc)(const stp_list_item_t *item1,
					   const stp_list_item_t *item2));
int stp_list_item_create(stp_list_t *list, stp_list_item_t *prev, void *data);
int stp_list_item_destroy(stp_list_t *list, stp_list_item_t *item);
stp_list_item_t *stp_list_item_prev(stp_list_item_t *item);
stp_list_item_t *stp_list_item_next(stp_list_item_t *item);
void *stp_list_item_get_data(const stp_list_item_t *item);
int stp_list_item_set_data(stp_list_item_t *item, void *data);


#ifdef __cplusplus
  }
#endif

#endif /* __GIMP_PRINT_H__ */
/*
 * End of $Id: gimp-print.h.in,v 1.17 2002/11/13 22:42:27 rleigh Exp $
 */
