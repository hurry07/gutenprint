/*		-*- Mode: C -*-
 *  $Id: gimp-print.h.in,v 1.19 2002/11/22 02:16:57 rlk Exp $
 *
 *   Print plug-in header file for the GIMP.
 *
 *   Copyright 1997-2000 Michael Sweet (mike@easysw.com) and
 *      Robert Krawitz (rlk@alum.mit.edu)
 *
 *   This program is free software; you can redistribute it and/or modify it
 *   under the terms of the GNU General Public License as published by the Free
 *   Software Foundation; either version 2 of the License, or (at your option)
 *   any later version.
 *
 *   This program is distributed in the hope that it will be useful, but
 *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 *   for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 * Revision History:
 *
 *   See ChangeLog
 */

/*
 * This file must include only standard C header files.  The core code must
 * compile on generic platforms that don't support glib, gimp, gtk, etc.
 */

#ifndef __GIMP_PRINT_H__
#define __GIMP_PRINT_H__

/*
 * Include necessary header files...
 */

#include <stddef.h>     /* For size_t */

#ifdef __cplusplus
extern "C" {
#endif


/*
 * Library versioning details
 */

/*
 * compile-time version
 */
#define GIMPPRINT_MAJOR_VERSION       (@GIMPPRINT_MAJOR_VERSION@)
#define GIMPPRINT_MINOR_VERSION       (@GIMPPRINT_MINOR_VERSION@)
#define GIMPPRINT_MICRO_VERSION       (@GIMPPRINT_MICRO_VERSION@)
#define GIMPPRINT_CURRENT_INTERFACE   (@GIMPPRINT_CURRENT_INTERFACE@)
#define GIMPPRINT_BINARY_AGE          (@GIMPPRINT_BINARY_AGE@)
#define GIMPPRINT_INTERFACE_AGE       (@GIMPPRINT_INTERFACE_AGE@)
#define GIMPPRINT_CHECK_VERSION(major,minor,micro)	\
  (GIMPPRINT_MAJOR_VERSION >  (major) ||		\
  (GIMPPRINT_MAJOR_VERSION == (major) &&		\
   GIMPPRINT_MINOR_VERSION > (minor)) ||		\
  (GIMPPRINT_MAJOR_VERSION == (major) &&		\
   GIMPPRINT_MINOR_VERSION == (minor) &&		\
   GIMPPRINT_MICRO_VERSION >= (micro)))

extern const unsigned int gimpprint_major_version;
extern const unsigned int gimpprint_minor_version;
extern const unsigned int gimpprint_micro_version;
extern const unsigned int gimpprint_current_interface;
extern const unsigned int gimpprint_binary_age;
extern const unsigned int gimpprint_interface_age;
extern const char* stp_check_version(unsigned int required_major,
				     unsigned int required_minor,
				     unsigned int required_micro);

/*
 * Constants...
 */

#define OUTPUT_GRAY             0       /* Grayscale output */
#define OUTPUT_COLOR            1       /* Color output */
#define OUTPUT_MONOCHROME       2       /* Raw monochrome output */
#define OUTPUT_RAW_CMYK         3       /* Raw CMYK output */
#define OUTPUT_RAW_PRINTER	4	/* Printer-specific raw output */

#define IMAGE_LINE_ART          0
#define IMAGE_SOLID_TONE        1
#define IMAGE_CONTINUOUS        2
#define NIMAGE_TYPES            3

#define COLOR_MODEL_RGB         0
#define COLOR_MODEL_CMY         1
#define NCOLOR_MODELS           2

/*
 * Abstract data type for interfacing with the image creation program
 * (in this case, the Gimp).
 *
 * The progress_init(), note_progress(), and progress_conclude() members
 * are used to enable the image layer to deliver notification of
 * progress to the user.  It is likely that these functions will be
 * dropped in the future, and if desired must be implemented in
 * get_row().
 *
 * get_appname() should return the name of the application.  This is
 * embedded in the output by some drivers.
 *
 * width() and height() return the dimensions of the image in pixels.
 *
 * bpp(), or bytes per pixel, is used in combination with the output type
 * and presence of a color map, if supplied, to determine the format
 * of the input:
 *
 * Output_type is OUTPUT_MONOCHROME, OUTPUT_COLOR, or OUTPUT_GRAY:
 *
 *    bpp           No color map                Color map present
 *     1            grayscale                   indexed color (256 colors)
 *     2            grayscale w/alpha           indexed color w/alpha
 *     3            RGB                         N/A
 *     4            N/A                         RGB w/alpha (RGBA)
 *
 * Output_type is OUTPUT_CMYK:
 *
 *    bpp           No color map                Color map present
 *     4            8 bits/plane CMYK           N/A
 *     8            16 bits/plane CMYK          N/A
 *
 * Output type is OUTPUT_RAW_PRINTER:
 *
 *    If the printer supports OUTPUT_RAW_PRINTER, the bpp value should be
 *    2 x the number of channels desired to print (the precise modes
 *    available are printer-dependent).  Each plane is therefore 2 bytes
 *    (16 bits) deep.
 *
 * init() is used to perform any initialization required by the image
 * layer for the image.  It will be called once per image.  reset() is
 * called to reset the image to the beginning.  It may (in principle)
 * be called multiple times if a page is being printed more than once.
 * The reset() call may be removed in the future.
 *
 * get_row() transfers the data from the image to the gimp-print
 * library.  It is called from the driver layer.  It should copy WIDTH
 * (as returned by the width() member) pixels of data into the data
 * buffer.  It normally returns STP_IMAGE_OK; if something goes wrong,
 * or the application wishes to stop producing any further output
 * (e. g. because the user cancelled the print job), it should return
 * STP_IMAGE_ABORT.  This will cause the driver to flush any remaining
 * data to the output.  It will always request rows in monotonically
 * ascending order, but it may skip rows (if, for example, the
 * resolution of the input is higher than the resolution of the
 * output).
 */

typedef enum stp_image_status
{
  STP_IMAGE_OK,
  STP_IMAGE_ABORT
} stp_image_status_t;

typedef struct stp_image
{
  void (*init)(struct stp_image *image);
  void (*reset)(struct stp_image *image);
  int  (*bpp)(struct stp_image *image);
  int  (*width)(struct stp_image *image);
  int  (*height)(struct stp_image *image);
  stp_image_status_t (*get_row)(struct stp_image *image, unsigned char *data,
                                int row);
  const char *(*get_appname)(struct stp_image *image);
  void (*progress_init)(struct stp_image *image);
  void (*note_progress)(struct stp_image *image, double current, double total);
  void (*progress_conclude)(struct stp_image *image);
  void *rep;
} stp_image_t;


/*
 * Basic data types for Gimp-Print
 */

/*
 * Opaque representation of a printer model
 */
typedef void *stp_printer_t;

/*
 * Opaque representation of printer setttings.
 *
 * The representation of printer settings has changed dramatically from 4.2.
 * All (well most, anyway) settings outside of basics such as the printer
 * model and sizing settings are now typed parameters.
 */
typedef void *stp_vars_t;

/*
 * The following types are permitted for a printer setting.  Not all
 * are currently implemented.
 */
typedef enum stp_parameter_type
{
  STP_PARAMETER_TYPE_INVALID,
  STP_PARAMETER_TYPE_STRING_LIST, /* Single string choice from a list */
  STP_PARAMETER_TYPE_DOUBLE,	/* Floating point number */
  STP_PARAMETER_TYPE_CURVE,	/* Curve (list of floats, NYI) */
  STP_PARAMETER_TYPE_FILE,	/* Filename (NYI, need to consider security) */
  STP_PARAMETER_TYPE_RAW	/* Raw, opaque data */
} stp_parameter_type_t;

/*
 * What kind of setting this is, for purpose of user interface.
 */
typedef enum stp_parameter_class
{
  STP_PARAMETER_CLASS_INVALID,
  STP_PARAMETER_CLASS_FEATURE,	/* Printer feature */
  STP_PARAMETER_CLASS_OUTPUT,	/* Output control */
  STP_PARAMETER_CLASS_PAGE_SIZE	/* Special for specifying page size */
} stp_parameter_class_t;

/*
 * What "level" a setting is at, for UI design.
 */
typedef enum stp_parameter_level
{
  STP_PARAMETER_LEVEL_INVALID,
  STP_PARAMETER_LEVEL_BASIC,
  STP_PARAMETER_LEVEL_ADVANCED
} stp_parameter_level_t;

/*
 * Representation of a choice list of strings.  The choices themselves
 * consist of a key and a human-readable name.  The list object is
 * opaque.
 */
typedef struct
{
  const char	*name,	/* Option name */
		*text;	/* Human-readable (translated) text */
} stp_param_string_t;

typedef void *stp_string_list_t;

/*
 * Other parameter types
 */

typedef struct
{
  size_t count;
  double *value;		/* List of doubles comprising the curve */
} stp_curve_t;

typedef char *stp_param_file_t;

typedef struct
{
  size_t bytes;
  void *data;
} stp_raw_t;

typedef struct
{
  double lower;
  double upper;
} stp_double_bound_t;

/*
 * Description of a parameter
 */
typedef struct
{
  const char *name;		/* Internal name (key) */
  const char *text;		/* User-visible name */
  const char *help;		/* Help string */
  stp_parameter_type_t type;
  stp_parameter_class_t class;
  stp_parameter_level_t level;
  union				/* Limits on the values */
  {				/* the parameter may take */
    stp_double_bound_t curve;
    stp_double_bound_t dbl;
    stp_string_list_t  str;
  } bounds;
  union				/* Default value of the parameter */
  {
    stp_curve_t *curve;
    double dbl;
    const char *str;
  } deflt;
} stp_parameter_t;


/*
 * Paper size
 */
typedef enum stp_papersize_unit
{
  PAPERSIZE_ENGLISH,
  PAPERSIZE_METRIC
} stp_papersize_unit_t;

typedef void *stp_papersize_t;

/*
 * Output function supplied by the calling application.
 */
typedef void (*stp_outfunc_t) (void *data, const char *buffer, size_t bytes);


/****************************************************************
*                                                               *
* PRINTER DESCRIPTION                                           *
*                                                               *
****************************************************************/

extern int stp_known_printers(void);
extern const stp_printer_t stp_get_printer_by_index(int idx);
extern const stp_printer_t stp_get_printer_by_long_name(const char *long_name);
extern const stp_printer_t stp_get_printer_by_driver(const char *driver);
extern const stp_printer_t stp_get_printer(const stp_vars_t v);
extern int stp_get_printer_index_by_driver(const char *driver);

extern const char * stp_printer_get_long_name(const stp_printer_t p);
extern const char * stp_printer_get_driver(const stp_printer_t p);
extern int stp_printer_get_model(const stp_printer_t p);
extern const stp_vars_t stp_printer_get_printvars(const stp_printer_t p);
extern void stp_set_printer_defaults(stp_vars_t, const stp_printer_t);


/****************************************************************
*                                                               *
* BASIC PRINTER SETTINGS                                        *
*                                                               *
****************************************************************/

extern stp_vars_t stp_allocate_vars(void);
extern void stp_copy_vars(stp_vars_t vd, const stp_vars_t vs);
extern stp_vars_t stp_allocate_copy(const stp_vars_t vs);
extern void stp_free_vars(stp_vars_t v);

extern void stp_set_driver(stp_vars_t v, const char *val);
extern void stp_set_driver_n(stp_vars_t v, const char *val, int bytes);
extern const char * stp_get_driver(const stp_vars_t v);

extern void stp_set_ppd_file(stp_vars_t v, const char *val);
extern void stp_set_ppd_file_n(stp_vars_t v, const char *val, int bytes);
extern const char * stp_get_ppd_file(const stp_vars_t v);

extern void stp_set_left(stp_vars_t v, int val);
extern void stp_set_top(stp_vars_t v, int val);
extern void stp_set_width(stp_vars_t v, int val);
extern void stp_set_height(stp_vars_t v, int val);
extern int stp_get_left(const stp_vars_t v);
extern int stp_get_top(const stp_vars_t v);
extern int stp_get_width(const stp_vars_t v);
extern int stp_get_height(const stp_vars_t v);

/*
 * For custom page widths, these functions may be used.
 */
extern void stp_set_page_width(stp_vars_t v, int val);
extern void stp_set_page_height(stp_vars_t v, int val);
extern int stp_get_page_width(const stp_vars_t v);
extern int stp_get_page_height(const stp_vars_t v);

/*
 * Set output type and image type.  These are likely to change
 * quite drastically, particularly image type.
 */
extern void stp_set_output_type(stp_vars_t v, int val);
extern int stp_get_output_type(const stp_vars_t v);

extern void stp_set_image_type(stp_vars_t v, int val);
extern int stp_get_image_type(const stp_vars_t v);

/*
 * Input color model refers to how the data is being sent to the
 * driver library; the default is RGB.  Output color model refers to
 * the characteristics of the device; the default is CMYK.  The output
 * color model is set by the printer driver and cannot be overridden.
 * It is provided to permit applications to generate previews using
 * the color machinery in Gimp-Print.  If this is done, normally
 * the output color model will be RGB.
 *
 * This is subject to change.
 */
extern void stp_set_input_color_model(stp_vars_t v, int val);
extern void stp_set_output_color_model(stp_vars_t v, int val);
extern int stp_get_input_color_model(const stp_vars_t v);
extern int stp_get_output_color_model(const stp_vars_t v);

/*
 * These functions are used to print output and diagnostic information
 * respectively.  These must be supplied by the caller.  Outdata and
 * errdata are passed as arguments to outfunc and errfunc; typically
 * they will be file descriptors.
 */
extern void stp_set_outfunc(const stp_vars_t v, stp_outfunc_t val);
extern void stp_set_errfunc(const stp_vars_t v, stp_outfunc_t val);
extern void stp_set_outdata(stp_vars_t v, void * val);
extern void stp_set_errdata(stp_vars_t v, void * val);
extern stp_outfunc_t stp_get_outfunc(const stp_vars_t v);
extern stp_outfunc_t stp_get_errfunc(const stp_vars_t v);
extern void * stp_get_outdata(const stp_vars_t v);
extern void * stp_get_errdata(const stp_vars_t v);

/*
 * Merge defaults for a printer with user-chosen settings
 */
extern void stp_merge_printvars(stp_vars_t user, const stp_vars_t print);


/****************************************************************
*                                                               *
* PARAMETER MANAGEMENT                                          *
*                                                               *
****************************************************************/

/*
 * List the available parameters for the currently chosen settings.
 * This does not fill in the bounds and defaults; it merely provides
 * a list of settings.  To fill in detailed information for a setting,
 * use stp_describe_parameter.
 */

extern const stp_parameter_t *
stp_list_parameters(const stp_vars_t v, int *count);

extern void
stp_describe_parameter(const stp_vars_t v, const char *name,
		       stp_parameter_t *description);

extern void stp_string_list_add_param(stp_string_list_t list,
				      const char *name, const char *text);

extern void stp_set_string_parameter(stp_vars_t v, const char *parameter,
				     const char *value);
extern void stp_set_string_parameter_n(stp_vars_t v, const char *parameter,
				       const char *value, int bytes);
extern void stp_set_float_parameter(stp_vars_t v, const char *parameter,
				    double value);
extern void stp_set_curve_parameter(stp_vars_t v, const char *parameter,
				     const stp_curve_t *value);
extern void stp_set_raw_parameter(stp_vars_t v, const char *parameter,
				     const stp_raw_t *value);

extern const char *stp_get_string_parameter(const stp_vars_t v,
					    const char *param);
extern const double stp_get_float_parameter(const stp_vars_t v,
					    const char *param);
extern const stp_curve_t *stp_get_curve_parameter(const stp_vars_t v,
						  const char *param);
extern const stp_raw_t *stp_get_raw_parameter(const stp_vars_t v,
					      const char *param);

/*
 * Manipulate lists of strings.  This will likely be subsumed by a more
 * general list manipulation technology.
 */

extern stp_string_list_t stp_string_list_allocate(void);
extern void stp_string_list_free(stp_string_list_t list);

extern stp_param_string_t *
stp_string_list_param(const stp_string_list_t list, size_t element);

extern size_t stp_string_list_count(const stp_string_list_t list);

extern stp_string_list_t
stp_string_list_duplicate(const stp_string_list_t list);

extern stp_string_list_t
stp_string_list_duplicate_params(const stp_param_string_t *list, size_t count);


/****************************************************************
*                                                               *
* LISTS                                                         *
*                                                               *
****************************************************************/

typedef void stp_list_item_t;
typedef void stp_list_t;

extern void stp_list_node_free_data(stp_list_item_t *item);
extern stp_list_t *stp_list_create(void);
extern int stp_list_destroy(stp_list_t *list);
extern stp_list_item_t *stp_list_get_start(stp_list_t *list);
extern stp_list_item_t *stp_list_get_end(stp_list_t *list);
extern stp_list_item_t *stp_list_get_item_by_index(stp_list_t *list,
						   int index);
extern stp_list_item_t *stp_list_get_item_by_name(stp_list_t *list,
						  const char *name);
extern stp_list_item_t *stp_list_get_item_by_long_name(stp_list_t *list,
						       const char *long_name);
extern int stp_list_get_length(stp_list_t *list);
extern void stp_list_set_freefunc(stp_list_t *list,
				  void (*node_freefunc)(stp_list_item_t *item));
extern void stp_list_set_namefunc(stp_list_t *list,
				  const char *(*namefunc)(const stp_list_item_t *item));
extern void stp_list_set_long_namefunc(stp_list_t *list,
				       const char *(*long_namefunc)(const stp_list_item_t *item));
extern void stp_list_set_sortfunc(stp_list_t *list, 
				  int (*sortfunc)(const stp_list_item_t *item1,
						  const stp_list_item_t *item2));
extern int stp_list_item_create(stp_list_t *list,
				stp_list_item_t *prev,
				void *data);
extern int stp_list_item_destroy(stp_list_t *list,
				 stp_list_item_t *item);
extern stp_list_item_t *stp_list_item_prev(stp_list_item_t *item);
extern stp_list_item_t *stp_list_item_next(stp_list_item_t *item);
extern void *stp_list_item_get_data(const stp_list_item_t *item);
extern int stp_list_item_set_data(stp_list_item_t *item,
				  void *data);

/****************************************************************
*                                                               *
* PAPER SIZE MANAGEMENT                                         *
*                                                               *
****************************************************************/

extern int stp_known_papersizes(void);
extern const stp_papersize_t stp_get_papersize_by_name(const char *name);
extern const stp_papersize_t stp_get_papersize_by_size(int l, int w);
extern const stp_papersize_t stp_get_papersize_by_index(int index);
extern const char * stp_papersize_get_name(const stp_papersize_t pt);
extern const char * stp_papersize_get_text(const stp_papersize_t pt);
extern unsigned stp_papersize_get_width(const stp_papersize_t pt);
extern unsigned stp_papersize_get_height(const stp_papersize_t pt);
extern unsigned stp_papersize_get_top(const stp_papersize_t pt);
extern unsigned stp_papersize_get_left(const stp_papersize_t pt);
extern unsigned stp_papersize_get_bottom(const stp_papersize_t pt);
extern unsigned stp_papersize_get_right(const stp_papersize_t pt);
extern stp_papersize_unit_t stp_papersize_get_unit(const stp_papersize_t pt);


/****************************************************************
*                                                               *
* INFORMATIONAL QUERIES                                         *
*                                                               *
****************************************************************/

/*
 * Retrieve the media size of the media type set in V, expressed in units
 * of 1/72".  If the media size is invalid, width and height will be set
 * to -1.  Values of 0 for width or height indicate that the dimension
 * is variable, so that custom page sizes or roll paper can be used.
 * In this case, the size limit should be used to determine maximum and
 * minimum values permitted.
 */
extern void stp_get_media_size(const stp_vars_t v, int *width, int *height);

/*
 * Retrieve the boundaries of the printable area of the page.  In combination
 * with the media size, this can be used to determine the actual printable
 * region, which callers can use to place the image precisely.  The
 * dimensions are relative to the top left of the physical page.
 *
 * If a customizable page size is used (see stp_printer_get_media_size),
 * the actual desired width and/or height must be filled in using
 * stp_set_page_width and/or stp_set_page_height.  If these are not filled
 * in, the margins will be returned.
 *
 * Returned values may be negative if a printer is capable of full bleed
 * by printing beyond the physical boundaries of the page.
 *
 * If the media size stored in V is invalid, the return value
 * will be indeterminate.  It is up to the user to specify legal values.
 */
extern void stp_get_imageable_area(const stp_vars_t v, int *left, int *right,
				   int *bottom, int *top);

/*
 * Retrieve the minimum and maximum size limits for custom media sizes
 * with the current printer settings.
 */
extern void
stp_get_size_limit(const stp_vars_t v, int *max_width, int *max_height,
		   int *min_width, int *min_height);


/*
 * Retrieve the printing resolution of the selected resolution.  If the
 * resolution is invalid, -1 will be returned in both x and y.
 */
extern void stp_describe_resolution(const stp_vars_t v, int *x, int *y);

/*
 * Verify that the parameters selected are consistent with those allowed
 * by the driver.  This must be called prior to printing; failure to do
 * so will result in printing failing.  Status of 0 represents failure;
 * status of 1 represents success; other status values are reserved.
 */
extern int stp_verify(const stp_vars_t v);


/****************************************************************
*                                                               *
* OPERATIONS                                                    *
*                                                               *
****************************************************************/

/*
 * stp_init() must be called prior to any other use of the library.
 */
extern int stp_init(void);

/*
 * Actually print the image.  Return value of 0 represents failure; status of 1
 * represents success; status of 2 represents abort requested by the driver.
 */
extern int stp_print(const stp_vars_t v, stp_image_t *image);


/****************************************************************
*                                                               *
* MISCELLANY                                                    *
*                                                               *
* All of this is very likely to change in the future            *
*                                                               *
****************************************************************/

/*
 * Set the encoding that all translated strings are output in.
 */
extern const char * stp_set_output_codeset(const char *codeset);

/*
 * hue_map is an array of 49 doubles representing the mapping of hue
 * from (0..6) to (0..6) in increments of .125.  The hue_map is in CMY space,
 * so hue=0 is cyan.  Interpolation between values is linear.
 *
 * lum_map and sat_map are correction factors for luminosity and saturation
 * respectively.  Both of these are inverse exponential.  The degree of
 * luminosity correction is scaled by the saturation of the particular
 * pixel.  This is likely to change drastically in the future.
 */
typedef void (*stp_convert_t) (const stp_vars_t vars, const unsigned char *in,
                               unsigned short *out, int *zero_mask,
                               int width, int bpp, const unsigned char *cmap,
                               const double *hue_map, const double *lum_map,
                               const double *sat_map);

/*
 * Choose the appropriate color function depending upon choice of input
 * and output.
 */
extern stp_convert_t stp_choose_colorfunc(int output_type, int image_bpp,
					  const unsigned char *cmap,
					  int *out_bpp, const stp_vars_t v);

/*
 * Please see the source in print-color.c for an explanation of this.
 */
extern void stp_set_lut(stp_vars_t v, void * val);
extern void * stp_get_lut(const stp_vars_t v);
extern void stp_allocate_lut(stp_vars_t v, size_t steps);
extern void stp_free_lut(stp_vars_t v);
extern void stp_compute_lut(stp_vars_t v, size_t steps);

/*
 * For use with indexed color: the LUT should be an array of 256
 * RGB values.
 */
extern void stp_set_cmap(stp_vars_t v, unsigned char * val);
extern unsigned char * stp_get_cmap(const stp_vars_t v);

/*
 * Default global settings.  The main use of this is to provide a usable
 * stp_vars_t for purposes of parameter inquiry in the absence of a
 * specific printer.  This is currently used in a variety of places
 * to get information on the standard color parameters without querying
 * a particular printer.
 */
extern const stp_vars_t stp_default_settings(void);


#ifdef __cplusplus
  }
#endif

#endif /* __GIMP_PRINT_H__ */
/*
 * End of $Id: gimp-print.h.in,v 1.19 2002/11/22 02:16:57 rlk Exp $
 */
